<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>http | Yang</title>

<link rel="shortcut icon" href="https://Yang-0394.github.io/favicon.ico?v=1605192345572">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://Yang-0394.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Yang
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1605192345572" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    http
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-11-12 ·
                    </time>
                    
                </div>
                <div class="post-content">
                    <p>知识图：</p>
<p>一、HTTP简介：<br>
http协议是Hyper Text Transfer Protocol(超文本传输协议)的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。<br>
http是一个基于TCP/IP通信协议来传递数据（HTML文件，图片文件，查询结果等）。<br>
http是一个属于应用层的面向对象的协议，由请求和响应构成，它不关心数据传输的细节，主要用来规定客户端和服务端的数据传输格式，最初是用来向客户端传输HTML页面的内容，默认端口是80。<br>
二、HTTP的版本<br>
1、HTTP 0.9版本	1991年<br>
这个版本就是最初用来向客户端传输HTML页面的，所以只有一个GET命令，然后服务器返回客户端一个HTML页面，不能是其他格式。利用这个版本可以构建一个简单的静态网站了。<br>
缺点：信息种类过于单一，无法满足需求，串行处理。<br>
2、HTTP 1.0版本	1996年<br>
第一个在通讯中指定版本号的HTTP协议版本，常用于代理服务器，成为了面向事务的应用层协议，该协议需要每请求一次响应建立并拆除一次连接，1.0引入了POST和HEAD命令，相对于0.9版本在一定程度上保障了数据传输安全，是一个典型的串行连接事务。<br>
缺点：串行处理，效率低下。<br>
3、HTTP 1.1版本	1999年<br>
引入持久连接机制并被默认采用，且更好的配合代理服务器工作，对于同一个域名，大多数浏览器允许同时建立6个持久连接引入了管道机制，还支持管道方式同一连接下同时发送多个请求，已降低线路负载，提高传输速度，新增方法：PUT、PATCH、OPTIONS、DELETE。<br>
缺点：同一TCP链接里，所有的通信按次序进行，服务器只能顺序处理回应，如果前面处理过慢，会有许多请求排队，造成对头阻塞。</p>
<p>4、HTTP 2.0版本	2005年<br>
头信息和数据体都是二进制，称为头信息帧和数据帧<br>
复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了“对头堵塞”，此双向的实时通信称为多工，引入头信息压缩机制，头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度，HTTP/2允许服务器未经请求，主动向客户端发送资源，即服务器推送。</p>
<p>补：HTTP管道机制解释：<br>
HTTP Pipelining是这样一种技术：在等待上一个请求响应的同时，发送下一个请求。(译者注：作者这个解释并不完全正确，HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。)但就像在超市收银台或者银行柜台排队时一样，你并不知道前面的顾客是干脆利索的还是会跟收银员/柜员磨蹭到世界末日（译者注：不管怎么说，服务器（即收银员/柜员）是要按照顺序处理请求的，如果前一个请求非常耗时（顾客磨蹭），那么后续请求都会受到影响），这就是所谓的线头阻塞（Head of line blocking）。</p>
<p>当然，你可以在选择队伍时候就做好功课，去排一个你认为最快的队伍，或者甚至另起一个新的队伍（译者注：即新建一个TCP连接）。但不管怎么样，你总归得先选择一个队伍，而且一旦选定之后，就不能更换队伍。<br>
但是，另起新队伍会导致资源耗费和性能损失（译者注：新建 TCP 连接的开销非常大）。这种另起新队伍的方式只在新队伍数量很少的情况下有作用，因此它并不具备可扩展性。（译者注：这段话意思是说，靠大量新建连接是不能有效解决延迟问题的，即HTTP Pipelining并不能彻底解决Head ofline blocking问题。）所以针对此问题并没有完美的解决方案。<br>
这就是为什么，即使在2015年的今天，大部分桌面浏览器仍然会选择默认关闭HTTP pipelining这一功能的原因。</p>
<p>三、HTTP主要特点<br>
1、简单快速：客户端向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户端与服务器联系的类型的不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2、灵活：HTTP允许传输任意类型的数据对象，正在传输的类型Content-Type加以标记。</p>
<p>3、无状态：就是说每次HTTP请求都是独立的，任何两个请求之间没有必然的联系。但是在实际应用中并不完全这样，引入Cookie和Session机制来关联请求。</p>
<p>4、多次HTTP请求：在客户端请求网页时多数情况下并不是一次就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如CSS, JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大的提高了效率。</p>
<p>5、基于TCP协议：HTTP协议的目的是规定客户端与服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。</p>
<p>四、HTTP之URL<br>
HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。<br>
URL全称是Uniform Resource Locator，中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。以下面的URL为例，介绍普通URL的各部分的组成：<br>
http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>
1、协议部分：该URL的协议部分为“http:&quot;，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等。http后面的”//“为分隔符。</p>
<p>2、域名部分：该URL的域名部分为“www.aspxfans.com”，一个URL中，也可以使用IP地址作为域名使用。</p>
<p>3、端口部分：跟在域名后面的是端口，域名和端口之间使用“：”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口。</p>
<p>4、虚拟目录部分：从域名的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”。</p>
<p>5、文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”，则是从域名后的最后一个“/”开始到“#”为止，是文件名部分，如果没有“?”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分，本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。</p>
<p>6、锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。</p>
<p>7、参数部分：从“?”开始到“#”为止，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数和参数之间用“&amp;”作为分隔符。</p>
<p>五、URL和URI的区别<br>
web上的可用的每种资源如HTML文档、图像、视频片段、程序等都是URI定位的<br>
URI一般由三部分组成：<br>
1、访问资源的命名机制<br>
2、存放资源的主机名<br>
3、资源自身的名称，由路径表示，着重强调于资源。</p>
<p>URL和URN（统一资源命名，命名资源但不定位资源）是URI的子集，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN是具体的资源标识的方式。</p>
<p>六、HTTP之请求消息Request<br>
客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<br>
请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</p>
<p>HTTP请求消息结构：</p>
<p>GET请求例子：</p>
<p>第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本。<br>
GET说明请求类型是GET，[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p>
<p>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。<br>
从第二行起为请求头部，HOST将指出请求的目的地，User-Agent服务端和客户端脚本都能访问它，它是浏览器类型检测逻辑的重要基础，该信息由你的浏览器来定义，并且在每个请求中自动发送等等。<br>
第三部分：空行，请求头部后面的空行是必须的。<br>
即使第四部分的请求数据为空，也必须有空行。<br>
第四部分：请求数据也叫请求主体，可以添加任意的的其他数据。<br>
这个例子的请求数据为空。</p>
<p>POST请求的例子：</p>
<p>第一部分：请求行，第一行表明了是post请求，以及http1.1版本。<br>
第二部分：请求头部，第二行至第六行。<br>
第三部分：空行，第七行的空行。<br>
第四部分：请求数据，第八行。</p>
<p>七、HTTP之响应消息Response<br>
一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p>
<p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<p>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>
第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<p>第二部分：消息报头，用来说明客户端要使用的一些附加信息<br>
第二行和第四行为消息报头，<br>
Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型</p>
<p>第三部分：空行，消息报头后面的空行是必须的<br>
第四部分：响应正文，服务器返回给客户端的文本信息。<br>
空行后面的html部分为响应正文。</p>
<p>七(1)HTTP之状态码<br>
状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<p>1xx：指示信息--表示请求已接收，继续处理<br>
2xx：成功--表示请求已被成功接收、理解、接受<br>
3xx：重定向--要完成请求必须进行更进一步的操作<br>
4xx：客户端错误--请求有语法错误或请求无法实现<br>
5xx：服务器端错误--服务器未能实现合法的请求</p>
<p>常见状态码：<br>
HTTP状态码一共有60多种，但是不用全部都记住，因为大部分在工作当中是不经常使用的。经常使用的大概就是16种，下面来详细介绍。（其实最最常用的也就8种，下面有背景色的就是）</p>
<p>1. 200：OK</p>
<p>这个没有什么好说的，是代表请求被正常的处理成功了。</p>
<p>2. 204：No Content</p>
<p>请求处理成功，但是没有数据实体返回，也不允许有实体返回。比如说HEAD请求，可能就会返回204 No Content，因为HEAD就是只获取头信息。这里简单提一下205 Reset Content，和204 No Content的区别是不但没有数据实体返回，而且还需要重置表单，方便用户再次输入。</p>
<p>3. 206：Partial Content</p>
<p>这是客户端使用Content-Range指定了需要的实体数据的范围，然后服务端处理请求成功之后返回用户需要的这一部分数据而不是全部，执行的请求就是GET。返回码就是206：Partial Content。</p>
<p>4. 301 ： Moved Permanently</p>
<p>代表永久性定向。该状态码表示请求的资源已经被分配了新的URL，以后应该使用资源现在指定的URL。也就是说如果已经把资源对应的URL保存为书签了，这是应该按照Location首部字段提示的URL重新保存。</p>
<p>5. 302：Found</p>
<p>代表临时重定向。该状态码表示请求的资源已经被分配了新的URL，但是和301的区别是302代表的不是永久性的移动，只是临时的。就是说这个URL还可能会发生改变。如果保存成书签了也不会更新。</p>
<p>6. 303：See Other</p>
<p>和302的区别是303明确规定客户端应当使用GET方法。</p>
<p>7. 304：Not Modified</p>
<p>该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但是没有满足条件。304状态码返回时不包含任何数据实体。304虽然被划分在3XX中但是和重定向没有关系。</p>
<p>8. 307：Temporary Redirect</p>
<p>临时重定向，与302 Found相同，但是302会把POST改成GET，而307就不会。</p>
<p>9.  400：Bad Request</p>
<p>400表示请求报文中存在语法错误。需要修改后再次发送。</p>
<p>10. 401：Unauthorized</p>
<p>该状态码表示发送的请求需要有通过HTTP认证的认证信息。</p>
<p>11. 403：Forbidden</p>
<p>表明请求访问的资源被拒绝了。没有获得服务器的访问权限，IP被禁止等。</p>
<p>12. 404：Not Found</p>
<p>表明请求的资源在服务器上找不到。当然也可以在服务器拒绝请求且不想说明理由时使用。</p>
<p>13. 408：Request Timeout</p>
<p>表示客户端请求超时，就是在客户端和服务器建立连接后服务器在一定时间内没有收到客户端的请求。</p>
<p>14. 500：Internal Server Error</p>
<p>表明服务器端在执行请求时发生了错误，很有可能是服务端程序的Bug或者临时故障。</p>
<p>15. 503：Service Unavailable</p>
<p>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After字段再返回给客户端。</p>
<p>16. 504：Getaway Timeout</p>
<p>网关超时，是代理服务器等待应用服务器响应时的超时，和408 Request Timeout的却别就是504是服务器的原因而不是客户端的原因<br>
八、HTTP请求方法<br>
根据HTTP标准，HTTP请求可以使用多种请求方法。<br>
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<p>GET     请求指定的页面信息，并返回实体主体。<br>
HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>
POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>
PUT     从客户端向服务器传送的数据取代指定的文档的内容。<br>
DELETE      请求服务器删除指定的页面。<br>
CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>
OPTIONS     允许客户端查看服务器的性能。<br>
TRACE     回显服务器收到的请求，主要用于测试或诊断。<br>
九、HTTP工作原理<br>
HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是HTTP请求响应的步骤：<br>
1、客户端连接到Web服务器<br>
一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。</p>
<p>2、发送HTTP请求<br>
通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应<br>
Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接<br>
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容<br>
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p>
<p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>
<p>5、释放 TCP连接;</p>
<p>6、浏览器将该 html 文本并显示内容; 　<br>
十、get和put的区别：<br>
1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>
<p>POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p>
<p>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变<br>
2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</p>
<p>而在实际开发中存在的限制主要有：</p>
<p>GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。</p>
<p>因此对于GET提交时，传输数据就会受到URL长度的 限制。</p>
<p>POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>
<p>3、安全性</p>
<p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击</p>
<p>4、Http get,post,soap协议都是在http上运行的</p>
<p>（1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的<br>
查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全</p>
<p>（2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。<br>
但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。</p>
<p>（3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式<br>
Content-type设置为: text/xml 任何数据都可以xml化。</p>
<p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p>
<p>我们看看GET和POST的区别</p>
<p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p>
<p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p>
<p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p>
<p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p>
<p>HTTP和HTTPS<br>
HTTP的不足<br>
通信使用明文(不加密),内容可能会被窃听<br>
不验证通信方的身份,因此有可能遭遇伪装<br>
无法证明报文的完整性,所以有可能已遭篡改</p>
<p>HTTPS介绍<br>
HTTP 协议中没有加密机制,但可以通 过和 SSL(Secure Socket Layer, 安全套接层 )或 TLS(Transport Layer Security, 安全层传输协议)的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密。</p>
<p>HTTP + 加密 + 认证 + 完整性保护 = HTTPS（HTTP Secure ）</p>
<p>HTTPS 采用共享密钥加密（对称）和公开密钥加密（非对称）两者并用的混合加密机制。若密钥能够实现安全交换,那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比,其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势, 将多种方法组合起来用于通信。 在交换密钥阶段使用公开密钥加密方式,之后的建立通信交换报文阶段 则使用共享密钥加密方式。</p>
<p>HTTPS握手过程的简单描述如下：</p>
<p>浏览器将自己支持的一套加密规则发送给网站。<br>
服务器获得浏览器公钥<br>
网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 浏览器获得服务器公钥<br>
获得网站证书之后浏览器要做以下工作：<br>
(a). 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。<br>
(b). 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（接下来通信的密钥），并用证书中提供的公钥加密（共享密钥加密）。<br>
(c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 浏览器验证 -&gt; 随机密码 服务器的公钥加密 -&gt; 通信的密钥 通信的密钥 -&gt; 服务器<br>
网站接收浏览器发来的数据之后要做以下的操作：<br>
(a). 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。<br>
(b). 使用密码加密一段握手消息，发送给浏览器。<br>
服务器用自己的私钥解出随机密码 -&gt; 用密码解密握手消息（共享密钥通信）-&gt; 验证HASH与浏览器是否一致（验证浏览器）<br>
HTTPS的不足<br>
加密解密过程复杂，导致访问速度慢<br>
加密需要认向证机构付费<br>
整个页面的请求都要使用HTTPS</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://Yang-0394.github.io/post/test/" class="post-title gt-a-link">
                    test
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">何处无月</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://Yang-0394.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
